{"version":3,"file":"bundle.js","sources":["../src/index.ts"],"sourcesContent":["// 类本身就可以充当类型，可以描述实例，也称为类类型\r\n// let str:String = new String();\r\n\r\n// =>ts 中要求所有的属性 必须先声明再使用（采用修饰符来声明）\r\n// 1.public 公开属性，父、子、外界都可以访问\r\n// 1.1 public 单独声明\r\n// class Circle {\r\n//   // x; // 默认就是public\r\n//   public x;\r\n//   public y;\r\n//   constructor (x: number, y:number){ // 构造函数就是函数，用法同函数\r\n//     this.x = x;\r\n//     this.y = y;\r\n//   }\r\n//   // ...\r\n// }\r\n\r\n// 1.2直接在构造函数的参数中声明属性，不用赋值也不会报错\r\n// class Animal {\r\n//   constructor(public name: string, public age: number){\r\n\r\n//   }\r\n// }\r\n// const animal = new Animal(\"动物\", 30);\r\n// console.log(animal);\r\n\r\n// =>继承 属性在父子及外界都可以访问\r\n// class Animal {\r\n//   constructor(public name: string, public age: number){\r\n//     this.name; // 父中访问属性\r\n//   }\r\n// }\r\n\r\n// class Cat extends Animal{\r\n//   constructor(name: string, age: number){\r\n//     super(name, age);\r\n//     this.name; // 子可以访问属性\r\n//   }\r\n// }\r\n// const tom = new Cat(\"动物\", 100);\r\n// console.log(tom.name); // 外界访问属性\r\n\r\n\r\n// 2.protected受保护的\r\n// class Animal {\r\n//   constructor(protected name: string, public age: number){\r\n//     this.name; // 父中访问属性\r\n//   }\r\n// }\r\n\r\n// class Cat extends Animal{\r\n//   constructor(name: string, age: number){\r\n//     super(name, age);\r\n//     this.name; // 子可以访问属性\r\n//   }\r\n// }\r\n// const tom = new Cat(\"动物\", 100);\r\n// console.log(tom.name); // 外界访问属性报错\r\n\r\n// 3.private 只能父类访问\r\n\r\n// class Animal {\r\n//   #xxx: string = 'abc';\r\n//   constructor(private name: string, public age: number){\r\n//     this.name; // 父类中可以访问属性\r\n//   }\r\n// }\r\n\r\n// class Cat extends Animal{\r\n//   constructor(name: string, age: number){\r\n//     super(name, age);\r\n//     this.name; // 子类不能访问父类属性\r\n//   }\r\n// }\r\n// const tom = new Cat(\"动物\", 100);\r\n// console.log(tom.name); // 外界不能访问\r\n\r\n// // 使用此方式可以访问私有属性，绕过ts检测\r\n// console.log(tom[\"name\"]); \r\n// // 在js语法中规定，使用 #xxx; 声明的变量为私有属性，在外界或者子类都访问不到\r\n// console.log(tom[\"#xxx\"]);\r\n\r\n// 4.readonly 仅读属性 只能初始化的时候赋值，后续不能修改\r\n// class Animal {\r\n//   constructor(public readonly name: string, public age: number){\r\n//     // 在构造函数中都算初始化，可以赋值\r\n//     this.name = 'abc'; \r\n//   }\r\n// }\r\n\r\n// class Cat extends Animal{\r\n//   constructor(name: string, age: number){\r\n//     super(name, age);\r\n//     // 子类无法修改父类中的只读属性\r\n//     // 报错：无法为“name”赋值，因为它是只读属性\r\n//     // this.name = 'abc'; \r\n//   }\r\n// }\r\n// const tom = new Cat(\"动物\", 100);\r\n// console.log(tom.name); \r\n\r\n// =>类的功能：主要是实例属性，原型方法，静态属性，属性访问器\r\n// 1.实例属性 x y\r\n// class Circle {\r\n//   public x;\r\n//   public y;\r\n//   constructor (x: number, y:number){ // 构造函数就是函数，用法同函数\r\n//     this.x = x;\r\n//     this.y = y;\r\n//   }\r\n//   // ...\r\n// }\r\n\r\n// 2.原型方法\r\n// class Animal {\r\n//   private _sound: string = '';\r\n//   constructor(public name: string, public age: number) {}\r\n//   get sound(){\r\n//     return this._sound;\r\n//   }\r\n//   set sound(value:string){\r\n//     this._sound = value;\r\n//   }\r\n//   // 原型方法 void不关心返回值\r\n//   eat(food: string): void{\r\n//     console.log(`正在吃${food}`);\r\n//   }\r\n// }\r\n\r\n// class Cat extends Animal {\r\n//   constructor(name: string, age: number) {\r\n//     super(name, age);\r\n//   }\r\n//   // 子类重写父类， 要保证兼容父类的类型\r\n//   eat(food: string) {\r\n//     return 'abc';\r\n//   }\r\n// }\r\n// let cat = new Cat('Tom', 18);\r\n// cat.sound = \"喵喵叫\";\r\n// console.log(cat.sound); // '喵喵叫'\r\n// cat.eat(\"猫粮\"); // '正在吃猫粮'\r\n\r\n// 3.静态属性\r\n// class Animal {\r\n//   static habitat = '地球';\r\n//   static getHabitat() {\r\n//     // this指向类本身 Animal\r\n//     return this.habitat;\r\n//   }\r\n// }\r\n\r\n// Animal.habitat;\r\n// Animal.getHabitat();\r\n\r\n// 4.属性访问器 === 类中的Object.defineProperty\r\n// class Animal {\r\n//   private _sound: string = '';\r\n//   constructor(public name: string, public age: number) {}\r\n//   get sound(){\r\n//     return this._sound;\r\n//   }\r\n//   set sound(value:string){\r\n//     this._sound = value;\r\n//   }\r\n// }\r\n\r\n// class Cat extends Animal {\r\n//   constructor(name: string, age: number) {\r\n//     super(name, age);\r\n//   }\r\n// }\r\n// let cat = new Cat('Tom', 18);\r\n// cat.sound = \"喵喵叫\";\r\n// console.log(cat.sound); // '喵喵叫'\r\n\r\n// super：原型方法是指向实例，构造函数和静态方法中指向父类\r\n\r\n// =>给类和构造函数添加修饰符\r\n// 1.给构造函数添加private，不能new\r\n// 1.1单例模式使用，只有一个类\r\nclass Singleton {\r\n  // 静态属性\r\n  private static instance = new Singleton();\r\n  private constructor() { }\r\n\r\n  // 静态方法\r\n  static getInstance() {\r\n    // this -> Singleton\r\n    this.instance;\r\n  }\r\n}\r\n// 不能new，类“Singleton”的构造函数是私有的，仅可在类声明中访问。\r\n// new Singleton();\r\n\r\n// 可以通过类调用实例上的方法\r\nlet ins1 = Singleton.getInstance();\r\nlet ins2 = Singleton.getInstance();\r\n\r\nconsole.log(ins1 === ins2); // true\r\n\r\n// 1.2 抽象类：如果父类定义了抽象方法，子类必须去实现\r\n//  + 不能new\r\n//  + 抽象类中可以创建抽象属性和方法，让子类来实现，静态方法、属性不可以\r\n//  + 抽象类中可以拥有具体的实现和非抽象的东西\r\nabstract class Animal {\r\n  static habitat = \"地球\";\r\n  // 没有具体实现\r\n  // 默认我们应该采用eat()这种方式来声明方法\r\n  abstract eat(): void; // 一般描述原型方法\r\n  abstract play: () => void; // 一般描述实例方法\r\n\r\n  // 有具体实现\r\n  drink() {   \r\n    console.log(\"喝水\");\r\n  }\r\n}\r\nclass Cat extends Animal {\r\n  eat(): void {\r\n\r\n  }\r\n  play: () => void = () => { };\r\n}\r\nlet cat = new Cat();\r\n\r\nconsole.log(cat);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport { }"],"names":[],"mappings":";;;EAAA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EAEA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAGA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EAEA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EAEA;EACA;EACA;EACA,MAAM,SAAS,CAAA;EAGb,IAAA,WAAA,GAAA,GAAyB;;EAGzB,IAAA,OAAO,WAAW,GAAA;;UAEhB,IAAI,CAAC,QAAQ,CAAC;OACf;;EARD;EACe,SAAA,CAAA,QAAQ,GAAG,IAAI,SAAS,EAAE,CAAC;EAS5C;EACA;EAEA;EACA,IAAI,IAAI,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;EACnC,IAAI,IAAI,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;EAEnC,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;EAE3B;EACA;EACA;EACA;EACA,MAAe,MAAM,CAAA;;MAQnB,KAAK,GAAA;EACH,QAAA,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;OACnB;;EATM,MAAO,CAAA,OAAA,GAAG,IAAI,CAAC;EAWxB,MAAM,GAAI,SAAQ,MAAM,CAAA;EAAxB,IAAA,WAAA,GAAA;;EAIE,QAAA,IAAA,CAAA,IAAI,GAAe,MAAK,GAAI,CAAC;OAC9B;MAJC,GAAG,GAAA;OAEF;EAEF,CAAA;EACD,IAAI,GAAG,GAAG,IAAI,GAAG,EAAE,CAAC;EAEpB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC;;;;;;"}